#字符串String

1.String用来定义字符串变量指向字符串对象。

2.String变量每次的修改其实都是生成了修的字符串对象，并指向他。

3.有两种定义方法

    ""和String()

    都是在堆内存之中开辟内存
    但是出现相同的内容时
    ""是在字符串常量池之中存储，而且相同内容只会在其中存储一份
    构造器会生成两个不同的对象

4.字符串内容的对比

    一般不适合用"=="比较，因为对比的是字符串的地址
    采用equals()和equalsIgnoreCase()

5.String 常用API
    
    substring(int beginIndex, int endIndex)

#Arraylist
集合和数组类似，是java一种数据存储类型

集合的长度不固定，适合做元素的增删操作

Arraylist是集合的一种，支持引用类型

public Arraylist()

范型相当于规定了一个标签，只有某个引用类型的数据才能添加进去

#static修饰符
##成员变量
1.静态成员变量

静态成员变量，有static修饰，属于类，内存中只加载一次

所有相同类的对象都可以访问这一成员变量，相当于共享了

一般用类名.静态成员变量这样访问（也可以不写类名）

2.实例成员变量

实例成员变量，无static修饰，存在于每个对象之中 

只能每个对象才能访问使用，因为一般是封装好了的

3.内存原理

静态成员变量是放在堆内存之中，创建类之后就会开辟一段内存

用类生成对象之后，对象的各个成员变量都在堆内存，他的地址放回到栈内存的变量里，同时这一块内存会和静态变量区进行关联

##成员方法
1.静态成员方法

有static修饰，属于类，建议用类名访问，也可以使用对象访问

如果该方法是以执行一个通用功能为目的，或者需要方便访问，则可以申明成静态方法

在同一个类中，可以不加类名访问静态方法

静态方法之中不能出现this关键字

静态方法只能访问静态变量，不能访问实例变量

2.实例成员方法

无static修饰，属于对象，只能使用对象触发访问 

表示对象自己的行为的，且方法中需要访问实例成员变量的，则该方法必须申明为实例方法

实例方法既可以访问实例成员，也可以访问静态成员

3.内存原理

首先将类.class提到方法区,同时将静态方法暴露出来可以使用，地址可以访问

所以main方法可以直接就被加载到栈内存之中

当在main方法之中创建了一个对象后，栈内存之中开辟一个空间保存这个对象的地址，这个对象的相关成员信息保存在堆内存之中

此时可以对象之中就会有实例方法的引用，此时可以通过这样在方法区之中对类之中的实例方法进行访问

4.工具类

一堆通用的静态方法组成

一般将构造方法私有化，工具类无需创建对象

#代码块
类的五大成分之一（成员变量、构造器、方法、代码块、内部类）

1.静态代码块static{}

需要通过static关键字来修饰，随着类的加载而加载，并且自动触发，只执行一次

在类加载的时候做一些静态数据初始化的操作

2.构造代码块{}(不常用)

每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行之前执行

用来初始化实例

#单例模式
##设计模式
前人已经设计好的较好的代码

##单例模式 
一个类只有一个对象

1.饿汉单例

定义一个类，把构造器私有

定义一个静态变量存储一个对象

2.懒汉单例

定义一个类，把构造器私有

定义一个静态变量存储一个对象

提供一个返回单例对象的方法

#继承
1.提供了关键字extends，可以让一个类和另外一个类建立起父子关系

当子类继承父类，子类就可以直接使用父类的公共的属性和方法

子类extends父类

2.内存原理

直接创建一个子类对象时，会在堆内存之中同时创建父类空间和子类空间，同时属于这个子类对象

##设计规范
1.子类相同特征放在父类之中定义，子类独有的属性和行为在子类自己之中定义

2.父类空间有共同的属性和方法，子类空间中时独有的属性和方法（默认值）

3.对属性进行修改，就是在对应的空间内进行操作

##特点

1.子类不能继承父类的构造器，子类可以继承父类私有成员，但是不能直接访问

2.java是单继承模式，一个子类只能继承一个父类

3.java支持多层继承

4.所有的类都是object的子类

5.子类可以共享父类的静态成员，能否继承父类的静态成员还有争议

##super关键字

和this用法相同，用来指代父类空间

##方法重写
子类需要父类的功能，但父类的该功能不能完全满足自己的需求

@override表示重写方法，解释性好，安全

重写方法的名称、形参列表必须和被重写方法的名称和参数列表一致（和方法重载不一样）

私有方法不能重写

子类重写父类方法时，访问权限必须大于或者等于父类（public>protected>缺省）

子类不能重写父类的静态方法！

##子类构造器的特点
子类中所有的构造器都会默认先访问父类中无参的构造器，再执行自己

子类初始化之前，一定会先对父类空间的成员进行初始化

子类中默认有一个super()，就是父类的构造器

当父类只有有参构造器时，子类之中一定要修改构造器，不然报错，一般是有参数无参数都提供

##this、super总结
this指代本类空间，可以用这个关键字访问本类的成员、方法和构造器（可以用来借用兄弟构造器）

super指代父类空间，可以用这个关键字访问父类的成员、方法和构造器

this() 和 super()都只能放在构造器的第一行，两者不能够共同存在于同一个构造器之中

#包

用来分门别类的管理不同类，类似于文件夹

语法格式：公司域名倒写.技术名称  包名建议全部英文小写

相同包下的类可以直接访问，不同包下的类必须导包才可以使用，格式是 import 包名.类名;

不同包之间的类名相同的问题，同一个类(比如Test)之中只能辨识一个相同类名的类(比如Cat),这时候要用其他的相同类名的类(其他包的Cat)，那就必须把包名
指出来。如com.xxk.package.cat

#权限修饰符
用来控制一个成员能够被访问的范围

可以修饰成员变量、方法、构造器和内部类

有四种作用范围由小到大（private<缺省<protected<public）

![Image text](/Users/xiaxingke/IdeaProjects/java_learning/src/images/权限修饰符的权限范围.png)

成员变量一般私有
方法一般公开

#final修饰符
final关键字代表最终

修饰方法则方法不能被改写；修饰变量则变量在第一次赋值后，不能再次被赋值；修饰类则该类是最终类，不能被继承

final修饰变量是基本类型，则数据值不能在发生改变；修饰引用类型，那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的

#集合
集合和数组类似，是java一种数据存储类型

集合的长度不固定，适合做元素的增删操作

集合中只能存储引用类型数据，如果要存储基本类型数据选用包装类

很强大，API很多

1.集合分为collection（单列）和map（双列）或者叫键值对




    