#常量
常量是使用了public static final修饰的成员变量，必须有初始化值，且执行过程之中其值不能被改变

    1.可以用作系统的配置信息，方便维护，可读性强
    
    2.常量明明规则：英文单词全部大写，多个单词下划线连接起来
    
    3.常量在编译阶段会将使用常量的地方替换成真实值

#枚举
一种数据结构，作用是为了做信息的标志和信息的分类

    修饰符 enum 枚举名称{ }
    
    枚举是最终类，不可以被继承
    
    构造器是私有的，枚举对外不能创建对象
    
    枚举类的第一行默认都是罗列枚举对象的名称的
    
    枚举类相当于是多例模式   

#抽象类
抽象类相当于是一个类的模版
    
    必须使用abstract修饰
    
    具体的抽象方法是将定义的子类必须完成的功能的基本要求

    没有方法体，只有方法声明/签名，必须abstract修饰

    有抽象方法就必须是抽象类

    抽象类是用来被继承的，抽象方法是交给子类重写实现的
    
    一个类如果继承了抽象类，那么必须重写所有的抽象方法，不然这个类也必须定义成抽象类

抽象类为什么不能创建对象？
    
    抽象类不能直接实例化，并且对抽象类使用 new 运算符会导致编译时错误。虽然一些变量和
    值在编译时的类型可以是抽象的，但是这样的变量和值必须或者为 null，或者含有对非抽象
    类的实例的引用（此非抽象类是从抽象类派生的）

    抽象类不能被封装

final和abstract有什么关系？

    互斥关系
    
    final是不能被修改，不能被继承的

    abstract就是用来修改，用来继承的

abstract的运用场景——模版方法

    模版方法中间加抽象方法，抽象方法留着给子类重写

    模版方法一般用final修饰，避免子类重写

#接口
接口是一组行为规范，是更加彻底的抽象，可以看成是一种特殊的类

    interface关键字

    JDK8之前的接口中只能是抽象方法和常量，没有其他

    接口不能实例化，没有构造器

    接口中的成员都是public修饰的

使用方法
    
    接口是用来实现的,用implements关键字

    有点类似于继承，可以实现多个接口（干爹）

    接口和接口是多继承的关系

    接口多继承可以整合为一个接口，便于子类实现，相当于把多个接口合并在一个里面

    接口多继承会将相同方法，包括返回值也要一样，合并，当返回值不一样时，进行接口多继承会出现规范冲突的问题

JDK8的新加功能

    在之前版本的接口之中新加了多个抽象方法，但是原来版本接口的实现类不需要这些功能，却不得不重写这些抽象方法，会功能开发带来大量的工作

    JDK8中允许直接定义带有方法体的方法

    第一种：默认方法。类似于普通实例方法，但必须用defult修饰，同时默认有public修饰，需要通过接口的实现类的对象来调用

    第二种：静态方法。必须用static修饰，同时默认有public修饰，接口的静态方法必须用本身的接口名来调用

    第三种：私有方法。私有的实例方法，必须用private修饰，只能在本接口中被其他默认方法或私有方法访问

    接口静态方法必须用接口来调用，会避免这样一个情况：当一个类继承多个接口，但是要调用多个接口同一名称的静态方法，这时候用类或者对象来调用就容易歧义

一些注意事项

    一个类既继承类父类，又实现了一个接口，当调用两个一样名称的方法，会默认调用父类之中的方法（先有亲爸才有干爹）

    一个接口继承了多个接口时，如果多个接口存在规范冲突则不能多继承，比如方法的返回值类型不一样

    一个类实现了多个接口，如果多个接口有同名的方法，只能改写这个同名方法，无法单独使用其中一个接口的方法